## Тестовые задания

1. Почему команды du и df могут показывать разный объем занимаемого дискового пространства?

2. Есть две директории. Допустим они называются A и B. В обеих директориях лежат тысячи файлов, в том числе одинаковые. Нужно удалить из директории B то, что есть в директории A. Как это сделать? Напишите решение на bash или python.

3. Напишите скрипт (рекомендуется на python), который добавляет хост в Zabbix и навешивает ему необходимые (перечисленные в качестве параметров скрипта) шаблоны. Если такой хост с необходимыми шаблонами уже есть, то скрипт ничего не делает и сообщает нам об этом. Если хост есть, но не хватает каких-либо шаблонов, то скрипт навешивает недостающие.

4. Составить SQL запрос в базу Zabbix для получения списка Топ 10 неподдерживаемых айтемов.

5. Напишите systemd-unit, на примере сервера iperf3. Назовите его iperf3.service. В какой директории его нужно создавать? Что сделать, чтобы сервис запустить? Опишите последовательность действий.

6. Как можно определить MTU сетевого канала? Напишите скрипт на bash или python, который это делает.

7. Что такое jitter (своими словами)? Каким образом можно замониторить данную метрику? Напишите скрипт на bash или python, который это делает.

8. Исправьте неправильно написанный Dockerfile. Есть условное Node.js приложение, и неправильно написанный Dockerfile, который не будет кэшироваться и будет занимать много места. Нужно переписать его в соответствии с best-practice.
9. Какие из этих команд нельзя выполнить в консоли: 
-  zabbix_proxy -c zabbix_proxy.conf -R log_level_increase 
- zabbix_proxy -c zabbix_proxy.conf -R config_cache_reload 
- zabbix_proxy -c zabbix_proxy.conf -R check_config 
- zabbix_proxy -c zabbix_proxy.conf -R housekeeper_execute
10. Чем отличаются утилиты zabbix_get и zabbix_sender? В каких кейсах удобно применять тип метрики zabbix trapper?

Плохой файл:

```yaml
FROM ubuntu:20.04
COPY ./src /app
RUN apt-get update -y
RUN apt-get install -y nodejs
RUN npm install
ENTRYPOINT ["npm"] CMD ["run", "prod"]
```


## Решения

1. Команда du показывается общий объем каталогов в дереве каталогов. В то время df показывает использующийся объем файловой системы. Удаление файла не будет полностью завершено пока его использует активный процесс, следовательно команда du обнаружит отсутствие данного файла, так как информации о нем в каталогах уже нет, а df будет считать что файл все еще занимает место, так как физически он еще не удален. 
2. Скрипт: 
```python
import os
from pathlib import Path

DIR1 = Path('/home/malum/test/dir1')
DIR2 = Path('/home/malum/test/dir2')


os.chdir('/home/malum/test/')
dir1 = os.listdir('./dir1/')
dir2 = os.listdir('./dir2/')
print(dir1)
print(dir2)

for f1 in dir1:
    if f1 in dir2:
            os.remove(f'{DIR2}/{f1}')
            
            

```
3. Скрипт:
```python
import requests  
import configparser  
import argparse  
  
  
#   Пример использования, регистр важен:  
# python3 zbx_crete.py --host "Test" --temp "Linux by Zabbix agent" --ip "192.168.122.89" --group "Linux servers"  
# python3 zabix_create2.py --host "test2" --temp "Aranet Cloud,Zabbix server health" --ip "192.168.122.89" --group "Hypervisors"  
  
ZABBIX_API = 'http://192.168.122.76:8080/api_jsonrpc.php'  # адрес API заббикса  
  
  
def arguments():  # функция считывает аргументы командной строки  
  
    parser = argparse.ArgumentParser(description='file')  
    parser.add_argument('--temp', dest='tmp', type=str)  # аргумент шаблона  
    parser.add_argument('--host', dest='host', type=str)  # хостнейм  
    parser.add_argument('--ip', dest='ip', type=str)  # аргумент ip адреса  
    parser.add_argument('--group', dest='group', type=str)  # аргумент группы  
    argument = parser.parse_args()  
    template = argument.tmp  
    ip_address = argument.ip  
    hostname = argument.host  
    grp_name = argument.group  
    listing = {'template': template, 'host': hostname, 'ip': ip_address, 'group': grp_name}  
    return listing  
  
  
def confparse():  # парсится конфиг в формате ini с данными подключения  
    config = configparser.ConfigParser()  
    config.read('./files/zbx-config.conf')  
    log = config['API']['login']  
    pwd = config['API']['password']  
    return {'userdata': {'login': log, 'password': pwd}}  
  
  
def auth(log, pwd):  # происходит аутентификация и возврат токена доступа  
    r = requests.post(ZABBIX_API, json={  
        "jsonrpc": "2.0",  
        "method": "user.login",  
        "params": {  
            "user": log,  
            "password": pwd},  
        "id": 0  
    })  
    access = r.json()['result']  
    return access  
  
  
def get_template_id(template, access):  # получение id шаблона по его имени  
    r = requests.post(ZABBIX_API, json={  
        "jsonrpc": "2.0",  
        "method": "template.get",  
        "params": {  
            "output": "extend",  
            "filter": {  
                "host": f"{template}"  
            }  
        },  
        "auth": f"{access}",  
        "id": 1  
    })  
    return r.json()  
  
  
def get_template_host(hostname, access):  # исходя из имени хоста получаем имена и id его темплейтов  
  
    r = requests.post(ZABBIX_API, json={  
        "jsonrpc": "2.0",  
        "method": "host.get",  
        "params": {  
            "output": ["hostid"],  
            "filter": {'host': hostname},  
            "selectParentTemplates": [  
                "templateid",  
                "name"  
            ]  
        },  
        "id": 1,  
        "auth": f"{access}"  
    })  
    return r  
  
  
def get_group_id(grp_name, access):  # получаем id группы из его названия  
    r = requests.post(ZABBIX_API, json={  
        "jsonrpc": "2.0",  
        "method": "hostgroup.get",  
        "params": {  
            "output": "extend",  
            "filter": {  
                "name": f"{grp_name}"  
            }  
        },  
        "auth": f"{access}",  
        "id": 1  
    })  
    result = r.json()  
    return result  
  
  
def add_server(hostname, ip_addr, grp_id, access):  # функция добавления сервера  
    r = requests.post(ZABBIX_API, json={  
        "jsonrpc": "2.0",  
        "method": "host.create",  
        "params": {  
            "host": f"{hostname}",  
            "interfaces": [  
                {  
                    "type": 1,  
                    "main": 1,  
                    "useip": 1,  
                    "ip": f"{ip_addr}",  
                    "dns": "",  
                    "port": "10050"  
                }  
            ],  
            "groups": [  
                {  
                    "groupid": f"{grp_id}"  
                }  
            ],  
  
            "inventory_mode": 0,  
            "inventory": {  
                "macaddress_a": "01234",  
                "macaddress_b": "56768"  
            }  
        },  
        "auth": f"{access}",  
        "id": 10  
    })  
    result = r.json()  
    print(result)  
    return result  
  
  
def link_template(host_id, template, access):  
    r = requests.post(ZABBIX_API, json={  
        "jsonrpc": "2.0",  
        "method": "host.massadd",  
        "params": {  
            "templates": [  
                {  
                    "templateid": f"{template}"  
                }  
            ],  
            "hosts": [  
                {  
                    "hostid": f"{host_id}"  
                }  
            ]  
        },  
        "auth": f"{access}",  
        "id": 1  
    })  
  
    print(r.json())  
  
  
def get_hosts(hostname, access):  
    req = requests.post(ZABBIX_API, json={  
  
        "jsonrpc": "2.0",  
        "method": "host.get",  
        "params": {  
            "output": ["hostid", "name"],  
            "filter": {"host": f"{hostname}"},  
        },  
        "id": 1,  
        "auth": access  
    })  
    result = (req.json())  
    result = result['result']  
    return result  
  
  
  
if __name__ == '__main__':  
  
    arg = arguments()  # получаем аргументы командной строки  
    host = arg['host']  # получение имени хоста из cli  
    tmp = arg['template'].split(',')  # получение имени шаблона из cli  
  
    group = arg['group']   # получение имени группы из cli  
    ip = arg['ip']  # получение ip адреса хоста из cli  
    userdata = confparse()  # получаем данные конфигурационного файла  
    login = userdata['userdata']['login']  
    password = userdata['userdata']['password']  
    token = auth(login, password)  # получение токена доступа к api  
  
  
    template_host = get_template_host(host, token).json()  # получение шаблонов хоста  
  
  
  
    lst = []  # список под id шаблонов хоста  
    group_id = get_group_id(group, token)['result'][0]['groupid']  
    templates_id = []  
  
  
    for i in tmp:  
        try:  
            templates_id.append(get_template_id(i, token)['result'][0]['templateid'])  # получаем id шабл, указанного через cli  
  
        except IndexError:  
            print('Не правильно введен один из шаблонов.')  
  
  
    if template_host['result'] == []:  # если хоста с таким именем нет в заббиксе  
        print('Хоста нет в zabbix, он будет добавлен')  
        add_server(host, ip, group_id, token)      # добавляем хост  
        host_id = get_hosts(host, token)[0]['hostid']  # получаем айдишник нового хоста  
        print(host_id)  
        for i in templates_id:  
            link_template(host_id, i, token)    # вешаем шаблоны  
    else:  
        print('Хост есть в zabbix. Добавление шаблонов.')  
        host_id = get_hosts(host, token)[0]['hostid']  
        for i in templates_id:  
            link_template(host_id, i, token)
```
4. Возникли проблемы с определением структуры базы данных zabbix, откуда брать данные по поведению метрик.
5. Сервис systemd должен быть описан в формате ini, есть несколько вариантов его запуска, к примеру через таймер в случае если это скрипт, либо же, если это бинарный файл который в состоянии поддерживать свою работоспособность и реагировать на внешние команды, самостоятельно. Юниты размещаются в директории /etc/systemd/system/  
Сервис:
```ini
[Unit]                                  # описание сервиса
Description=service iperf3  
  
[Service]                               # тип (service, timer, etc)
Wants=iperf3.timer  # зависимость
Type=simple  
User=root                               #  юзер, от которого работает сервис
ExecStart=/usr/bin/iperf3 -c 192.168.122.76 -u -b 10m -J > /tmp/last-report.json  
                                        # выше параметры запуска
[Install]                               # 
WantedBy=default.target
```
Таймер:
```ini
[Utit]  # описание таймера и указание запускать после инициализации подсистемы сети
Description=Timer for iperf3
After=network.target
  
[Timer]  # Тип таймер
Unit=iperf3.service  
OnBootSec=1m  
OnActiveSec=30m  
OnUnitActive=30m  
  
[Install]  
WantedBy=default.target
```
Управление сервисами осуществляется командами:
```bash
systemctl status/start/restart/stop name.service/timer/etc
```
В данном случае управление ведется таймером, которые управляет запуском сервиса.

6. Определить MTU можно командой, соответственно, использовать ее в скриптах:```
```bash
ip a | grep -i mtu | awk '{print $5}'
```
7. Jitter - это разность по времени при прохождении пакетов. Определить его можно утилитой iperf3, которая так же умеет формировать вывод в json формате, замониторить можно заббиксом, создав элемент данных, к примеру, траппер, и вытаскивая поле "jitter_ms" с помощью JSONPath.  Пример команды:
```bash
iperf3 -c 192.168.122.76 -u -b 10m -J > report.json
```
8. Измененный докерфайл указан ниже. Теперь скопированные файлы не закрепляются в слой контейнера, а копируются каждый раз при его старте.

```yaml
FROM ubuntu:20.04
RUN apt-get update -y && apt-get install -y nodejs
RUN npm install
COPY ./src /app
ENTRYPOINT ["npm"]
CMD ["run", "prod"]
```

9. Какие из этих команд нельзя выполнить в консоли: 
-  zabbix_proxy -c zabbix_proxy.conf -R check_config 


10. zabbix_sender отправляет метрики в zabbix сервер, а zabbix_get используется для получения какой либо информации от агента. Использовать траппер с zabbix_sender имеет смысл когда необходимо выполнить какой либо большой скрипт, либо же что то, что может вызвать таймауты, в таком случае использование externalscript не подойдет и следует использовать zabbix_sender.
